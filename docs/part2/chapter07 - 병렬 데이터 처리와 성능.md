# Chapter 7 병렬 데이터 처리와 성능      
## 목차
[7.1 병렬스트림 ](#71-병렬-스트림)  

* [7.1.1 순차 스트림을 병렬 스트림으로 변환하기](#711-순차-스트림을-병렬-스트림으로-변환하기)
* [7.1.2 스트림 성능 측정](#712-스트림-성능-측정)
* [7.1.3 병렬 스트림의 올바른 사용법](#713-병렬-스트림의-올바른-사용법)
* [7.1.4 병렬 스트림 효과적으로 사용하기](#714-병렬-스트림-효과적으로-사용하기)

[7.2 포크 조인 프레임워크](#72-포크-조인-프레임워크)    
* [7.2.1 recursivetask 사용](#721-recursivetask-사용)
* [7.2.2 포크 조인 프레임워크를 제대로 사용하는 방법](#722-포크-조인-프레임워크를-제대로-사용하는-방법)
* [7.2.3 작업 훔치기](#723-작업-훔치기)

[7.3 Spliterator 인터페이스 ](#73-spliterator-인터페이스)  
* [7.3.1 분할 과정](#731-분할-과정)
* [7.3.2 Spliterator의 특성](#732-spliterator의-특성)

## 7.1 병렬 스트림

- 스트림 인터페이스를 이용하면 아주 간단하게 요소를 병렬로 처리가능하다. 
- 컬렉션에 parallelStream을 호출하면 병렬 스트림이 생성된다. 
- 병렬스트림이란 각각의 스레드에서 처리할 수 있도록 스트림 요소를 여러 청크 요소로 분할한 스트림이다.

### 7.1.1 순차 스트림을 병렬 스트림으로 변환하기
- 순차 스트림에 parallel을 호출해도 스트림 자체에는 아무 변화도 일어나지 않는다. 
- 내부적으로 parallel을 호출하면 이후 연산이 병렬도 수행해야 함을 의미하는 불리언 플래그가 설정된다. 
```java
Stream.iterate(1L, i-> i +1)
                 .limit(n)
                 .parallel()
                 .reduce(0L, Long::sum);
```
### 7.1.2 스트림 성능 측정 
- 병렬화를 이용하면 순차, 반복 형식에 비해 성능이 더 좋아질 것이라 추측하지만 추측은 위험한 방법이다. 
- 성능을 최적화 할 때는 측정을 하는 것이 중요하다.

### 7.1.3 병렬 스트림의 올바른 사용법 
- 병렬 스트림을 잘못 사용하면서 발생하는 많은 문제는 공유된 상태를 바꾸는 알고리즘을 사용하기 때문에 일어난다. 

### 7.1.4 병렬 스트림 효과적으로 사용하기 
- 양을 기준으로 병렬스트림 사용을 결정하는 것은 올바르지 않다. 
- 성능 측정을 통해서 병렬, 순차 스트림 선택 해야 한다. 
- 박싱과 언박싱은 성능을 크게 저하시킬 수 있는 요소다. 기본형 특화 스트림을 사용하는 것이 좋다. 
- 순차 스트림보다 병렬 스트림에서 성능이 더 떨어지는 연산이 있다. 요소의 순서에 의존하는 연산을 병렬 스트림에서 수행할려면 비싼 비용을 치뤄야 한다. 
- 스트림ㅇ에서 수행하는 전체 파이프라인 연산 비용을 고려해야 한다. 처리 요소 수가 N, 하나 당 처리 비용이 Q 라고 하면 전체 비용을 N * Q이다. 
- Q가 높아진다는 것은 병렬 스트림으로 성능을 개선할 수 있는 가능성이 있음을 의미한다. 
- 소량의 데이터 에서는 병렬 스트림은 도움이 되지 않는다. 
- 스트림을 구성하는 자료 구조가 적절한지 확인해야 한다. 
- 스트림의 특성, 파이프라인 중간 연산이 스트림의 특성을 어떻게 바꾸는지에 따라 분해 과정의 성능이 달라질 수 있다. 
- 최종 연산 비용을 살펴야 한다. 병합 과정의 비용이 비싸면 병렬 스트림으로 얻은 성능의 이익이 서브스트림의 부분 결과를 합치는 과정에서 상쇄될 수 있다.

| 항목 | 평가     |
|----|---|
| ArrayList | 훌륭함   |
| LinkedList | 나쁨     |
| IntStream.range | 훌륭함   |
| Stream.iterate | 나쁨     |
| HashSet | 좋음     |
| TreeSet | 좋음     |
***
## 7.2 포크 조인 프레임워크
- 포크 조인 프레임워크는 병렬화할 수 있는 작업을 재귀적으로 작은 작업으로 분할한 다음애 서브테스트 각각의 결과를 합쳐서 전체 결과를 만들도록 설계되었다. 
- 포크 조인 프레임워크에서는 서브테스크를 스레드 풀의 작업자 스레드에 분산 할당하는 ExecutorService 인터페이스를 구현한다. 
### 7.2.1 RecursiveTask 사용 
- 스레드 풀을 이용하려면 RecursiveTask<R>의 서브클래스를 만들어야 한다. 
- R은 병렬화된 테스크가 생성하는 결과 형식 또는 결과가 없을 경우는 RecursiveAction형식이다. 
- RecursiveTask를 정의하려면 추상메서드 compute를 구현해야 한다. 
- compute 메서드 구현은 아래와 같은 의사코드 형식을 유지한다. 
```java
if (태스크가 충분히 작거나 더 이상 분할할 수 없으면) { 
    순차적으로 태스크 계산
} else {
    태스크를 두 서브태스크로 분할
    태스크가 다시 서브태스크로 분할되도록 이 메서드를 재귀적으로 호출함 모든 서브태스크의 연산이 완료될 때까지 기다림
    각 서브태스크의 결과를 합침
}
```
- 일반적으로 애플리케이션에서는 둘 이상의 ForkJoinPool을 사용하지 않는다. 
- 소프트웨어의 필요한 곳에서 언제든 가져다 쓸 수 있도록 한번만 인스턴스화 해서 정적 필드에 싱글턴으로 저장한다. 

### 7.2.2 포크 조인 프레임워크를 제대로 사용하는 방법 
- join 메서드를 테스크에 호출하면 생산 결과가 준비될 때 까지 호출자를 블록시키기 때문에 두 서브 테스크가 모든 시작된 다음에 join을 호출해야한다. 
- RecursiveTask내에서는 ForkJoinPool 의 invoke 메서드를 사용하지 말아야한다. 
- 서브태스크에 fork메서드를 호출해서 ForkJoinPool의 일정을 조절할 수 있다. 

### 7.2.3 작업 훔치기 
- 포크 조인 프레임워크에서는 작업 훔치기라는 기법으로 이 문제를 해결한다. 
- 작업 훔 치기 기법에서는 ForkJoinPool의 모든 스레드를 거의 공정하게 분할한다. 
- 각각의 스레드는 자 신에게 할당된 태스크를 포함하는 이중 연결 리스트를 참조하면서 작업이 끝날 때 마다 큐의 헤드에서 다른 태스크를 가져와서 작업을 처리한다. 
- 이때 한 스레드는 다른 스레드 보다 자신에게 할당된 태스크를 더 빨리 처리할 수 있다. 
- 다른 스레드는 바쁘게 일하고 있 는데 한 스레드는 할일이 다 떨어진 상황일 때 유휴 상태로 바뀌 는 것이 아니라 다른 스레드 큐의 꼬리에서 작업을 훔쳐온다. 
- 모든 태스크가 작업을 끝낼 때 까지, 즉 모든 큐가 빌 때까지 이 과정을 반복한다. 
- 따라서 태스크의 크기를 작게 나누어야 작업자 스레드 간의 작업부하를 비슷한 수준으로 유지할 수 있다.
***
## 7.3 Spliterator 인터페이스 
- 자바 8에서는 Spliterator라는 새로운 인터페이스를 제공한다. 
- Iterator 처럼 Spliterator는 소스의 요소 탐색 기능을 제공한다는 점은 같지만 Spliterator은 병렬 작업에 특화되어있다. 
```java
public interface Spliterator<T> {
    boolean tryAdvance(Customer<? super T> action);
    Spliterator<T> trySplit();
    long estimateSize();
    int characteristics();
}
```
- tryAdvance메서드는 Spliterator의 요소를 하나씩 순차적으로 소비 하면서 탐색해야할 요소가 남아 있으면 참을 반환한다. 
- trtSplit 메서드는 Spliterator의 일부 요소를 분할 후 Spliterator를 생성한다. 
- estimateSize 메서드는 탐색해야 할 요소수 정보를 제공한다. 

### 7.3.1 분할 과정 
- 1단계 trySplit 호출 후 두 번째 Spliterator가 생성된다. 
- 2단계 두개의 Spliterator에서 trySplipt를 호출하면 네 개의 Spliterator이 생성된다. 
- trySplipt의 결과가 null이 될 때까지 반복하고 재귀 분할 과정이 종료된다. 
- 
### 7.3.2 Spliterator의 특성
- characteristics라는 추상 메서드도 정의한다. Characteristics 메서드는 Spliterator 자체의 특성 집합을 포함하는 int를 반환한다. 
- Spliterator를 이용하는 프로그램은 이들 특성을 참고해서 Spliterator를 더 잘 제어하고 최적화할 수 있다.
***
> 마틴 게이브리얼 우르마, 『모던 자바 인 액션』, 한빛미디어 (2019)  

