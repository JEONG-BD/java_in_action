# Chapter 17 리액티브 프로그래밍 
## [목차]
[17.1 리액티브 메니패스토]()  
* [17.1.1 애플리케이션 수준의 리액티브]()
* [17.1.2 시스템 수준의 리액티브]()

[17.2 리액티브 스트림과 플로 API]()
* [17.2.1 Flow 클래스 소개]()
* [17.2.2 첫번째 리액티브 애플리케이션 만들기]()
* [17.2.3 Processor로 데이터 변환하기]()
* [17.2.4 자바는 왜 플로 API 구현을 제공하지 않는가?]()

[17.3 리액티브 라이브러이 RxJava 사용하기]()
* [17.3.2 Observable를 변환하고 사용하기]()
* [17.3.1 Observable 만들고 사용하기]()
## 17.1 리액티브 메니패스토
#### 리액티브 매니패스토의 핵심 원칙
- 반응성 : 빠를 뿐만 아니라 일정하고 예상할 수 있는 반응 시간을 제공함에 따라 사용자가 기대치를 가질 수 있다. 
- 회복성 : 장애가 발생해도 시스템은 반응해야 한다. 
- 탄력성 : 애플리케이션의 생명 주기 동안 다양한 작업 부하를 받는데 작업 부하가 발생하면 자동으로 할당 자원수를 늘린다. 
- 메시지주도 : 비동기 메시지를 전달해서 컴포넌트 끼리의 통신이 이루어진다. 

### 17.1.1 애플리케이션 수준의 리액티브
- 애플리케이션 수준 컴포넌트의 리액티브 프로그래밍의 주요 기능은 비동기로 작업을 수행 할 수 있다는 점이다.
- 스트림을 블록하지 않고 비동기로 처리하는 것이 최신 멀티코어 CPU의 사용률을 극대화 할 수 있도록 리액티브 프레임워 크와 라이브러리는 스레드를 퓨처, 액터, 일련의 콜백을 발생시키는 이벤트 루프 등과 공유하고 처리할 이벤트를 변환하고 관리한다. 
- 위 기술들은 스레드보다 가볍고, 동시/비동기 애플리케이션 구현의 추상 수준을 높일 수 있으며 블록, 경쟁 조건, 데드닥 같이 저수준의 멀티 스레드 문제를 직접 처리할 필요가 없다. 
### 17.1.2 시스템 수준의 리액티브
- 리액티브 시스템은 여러 애플리케이션이 한 개의 일관적인, 회복할 수 있는 플랫폼을 구성할 수 있게 해주며 애플리케이션 중 하나가 실패해도 전체 시스템은 계속 운영될 수 있도록 도와주는 소프트웨어 아키텍처다.
- 리액티브 시스템의 주요 속성으로 메시지 주도를 꼽을 수 있는데시지는 정의된 목적지 하나를 향하는 반면, 이벤트는 관련 이벤트를 관찰하도록 등록한 컴포 넌트가 수신한다는 점이 다르다. 리액티브 시스템에서는 수신자와 발신자가 각각 수신 메시지, 발신 메시지와 결합하지 않도록 이들 메시지를 비동기로 처리해야 한다.
- 컴포넌트를 완전히 고립하려면 이들이 결합되지 않도록 해야 하고 그 결과로 시스템이 장애(회복성)와 높은 부하 (탄력성)에서도 반응성을 유지할 수 있다.
#### 장애 고립 
- 고립과 비결합이 회복성의 핵심이다!
- 리액티브 아키텍처에서는 컴포넌트에서 발생한 장애를 고립시킴으로 문제가 주변의 다른 컴포넌트로 전파되면서 전체 시스템 장애로 이어지는 것을 막음으로 회복성을 제공한다.

#### 위치 투명성 
- 위치투명성은 탄력성의 핵심이다! 
- 위치 투명성은 리액티브 시스템의 모든 컴포넌트가 수신자의 위치에 상관없이 다른 모든 서비스와 통신할 수 있음 을 의미한다. 
- 위치 투명성 덕분에 시스템을 복제할 수 있으며 현재 작업 부하에 따라 (자동으 로) 애플리케이션을 확장할 수 있다.
## 17.2 리액티브 스트림과 플로 API
### 17.2.1 Flow 클래스 소개
### 17.2.2 첫번째 리액티브 애플리케이션 만들기
### 17.2.3 Processor로 데이터 변환하기
### 17.2.4 자바는 왜 플로 API 구현을 제공하지 않는가?
## 17.3 리액티브 라이브러이 RxJava 사용하기
### 17.3.1 Observable 만들고 사용하기
### 17.3.2 Observable를 변환하고 사용하기 