
# Chapter 14 자바 모듈 시스템 
## [목차]

[14 들어가며](#14-들어가며)
[14.1 압력 소프트웨어 유추](#141-압력-소프트웨어-유추) 

* [14.1.1 관심사 분리](#1411-관심사-분리) 
* [14.1.2 정보 은닉](#1412-정보-은닉) 
* [14.1.3 자바 소프트웨어](#1413-자바-소프트웨어) 

[14.2 자바 모듈 시스템을 설계한 이유](#142-자바-모듈-시스템을-설계한-이유)

* [14.2.1 모듈화의 한계](#1421-모듈화의-한계) 
* [14.2.2 거대한 JDK](#1422-거대한-jdk) 
* [14.2.3 OSGi 와 비교](#1423-osgi-와-비교) 

[14.3 자바 모듈 : 큰 그림](#143-자바-모듈--큰-그림) 

[14.4 자바 모듈 시스템으로 애플리케이션 개발하기](#144-자바-모듈-시스템으로-애플리케이션-개발하기) 
* [14.4.1 애플리케이션 셋업](#1441-애플리케이션-셋업) 
* [14.4.2 세부적인 모듈화와 거친 모듈화](#1442-세부적인-모듈화와-거친-모듈화) 
* [14.4.3 자바 모듈 시스템 기초](#1443-자바-모듈-시스템-기초)

[14.5 여러 모듈 활용하기](#145-여러-모듈-활용하기) 
* [14.5.1 exports 구문](#1451-exports-구문) 
* [14.5.2 requires 구문](#1452-requires-구문) 
* [14.5.3 이름 정하기](#1453-이름-정하기) 

[14.6 컴파일과 패키징](#146-컴파일과-패키징)   
[14.7 자동모듈](#147-자동모듈)  
[14.8 모듈 정의와 구문들](#148-모듈-정의와-구문들) 
* [14.8.1 requires](#1481-requires) 
* [14.8.2 exports](#1482-exports) 
* [14.8.3 requires transitive](#1483-requires-transitive)
* [14.8.4 exports to](#1484-exports-to) 
* [14.8.5 open과 opens](#1485-open과-opens) 
* [14.8.6 users 와 provides](#146-컴파일과-패키징) 

[14.9 더 큰 예제 그리고 더 배울 수 있는 방법](#149])


## 14 들어가며
- 자바 9에서 가장 많이 거론되는 새로운 기능은 바로 모듈 시스템이다. 
### 14.1 압력 소프트웨어 유추
### 14.1.1 관심사 분리
- Soc(Separation of concerns)는 컴퓨터 프로그램을 고유 기능으로 나누는 동작을 권장하는 원칙이다. 
- 클래스를 그룹화한 모듈을 이용해서 애플리케이션의 클래스 간의 관계를 시각적으로 보여줄 수 있다. 
- 이미 자바 패키지가 클래스를 그룹으로 만들 수 있지만 모듈은 클래스가 어떤 다른 클래스를 볼 수 있는지를 컴파일 시간에 정교하게 제어 가능하다. 
- SoC원칙은 모델, 뷰, 컨트롤러 같은 아키텍터의 관점 그리고 복구 기법을 비즈니스 로직과 분리 하는등의 하위 수준 접근등의 상황에 유용하다. 
#### Soc 원칙의 장점 
- 개별 기능을 따로 작업할 수 있으므로 팀이 쉽게 협업 가능하다. 
- 개별 부분을 재사용하기 쉽다. 
- 전체 시스템을 쉽게 유지 보수 할 수 있다. 

### 14.1.2 정보 은닉
- 정보 은닉은 세부 구현을 숨기도록 장려하는 원칙이다. 
- 소프트웨어를 개발할 때 요구사항은 자주 바뀐다. 세부구현을 숨김으로써 프로그램의 어떤 부분을 바꿨을 때 다른 부분까지 영양을 미칠 가능성을 줄일 수 있다. 
- 캡슐화는 특정 코드 조각이 애플리케이션의 다른 부분고 고립되어 있음을 의미한다. 

### 14.1.3 자바 소프트웨어
- 자바의 접근 지정자, 패키지 수준 접근 권한등을 이용해서 메서드 필드 클래스 접근을 제어했지만 원하는 접근 제한을 달성하기 어렵다.  
***
## 14.2 자바 모듈 시스템을 설계한 이유
### 14.2.1 모듈화의 한계
- 자바 9 이전까지 모듈화된 소프트웨어 프로젝트를 만드는데 한계가 있었다.
- 자바는 클래스, 패키지, JAR 세가지 수준의 코드 구룹화를 제공했고 클래스와 관련해 자바는 제한자와 캡슐화를 지원했다.
- 패키지와 JAR 수준에서는 캡슐화를 지원하지 않았다.
#### 제한된 가시성 제어 
- 패키지 간의 가시성은 어떻게 제어해야 하는가? 
- 한 패키지의 클래스와 인터페이스를 다른 패키지로 공개하려면 public로 이들을 선언해야 하고 이들 클래스와 인터페이스는 모두 공개된다. 
#### 클래스 경로 
- 클래스를 모두 컴파일 한 후 한 개의 평범한 JAR파일에 넣고 클래스 경로에 이 JAR파일을 추가해 사용할 수 있다.
- JVM이 동적으로 클래스 경로에 정의된 클래스를 필요할 때 마다 읽지만 클래스 경로 JAR 조합에는 몇 가지 약점이 존재한다. 
- 클래스 경로에는 같은 클래스를 구분하는 버전 개념이 없다. 
- 클래스 경로는 명시적인 의존성을 지원하지 않는다. 
### 14.2.2 거대한 JDK
- JDK는 자바 프로그램을 만들고 실행하는데 도움을 주는 도구의 집합이다. 
- 자바 프로그램을 컴파일 하는 javac, 자바 애플리케이션을 로드하고 실행하는 java, 입출력 포함 런타임 자원을 제공하는 JDK 라이브러리, 컬렉션, 스트림 등이 있다. 
- 하지만 JDK 전부를 필요로 하지 않을 경우와 같이 JDK 자체도 모듈화 할 수 있는 자바 모듈 시스템 설계의 필요성이 제기 되었다.
### 14.2.3 OSGi 와 비교
- OSGI는 자바 9가 등장할 때 까지 JVM에서 모듈화 애플리케이션을 구현하는 표준이었다.
***
## 14.3 자바 모듈 : 큰 그림
- 모듈은 module이라는 새 키워드에 이름과 바디를 추가해서 정의한다. 
- 모듈 디스크립터는 module-info.java 라는 특별한 파일에 저장된다. 
- 모듈 디스크립터는 보통 패키지와 같은 폴더에 위치하며 한 개 이상의 패키지를 서술하고 캡슐화할 수 있지만 단순한 상황에서는 이들 패키지 중 하나만 외부로 노출시킨다. 

### 14.4 자바 모듈 시스템으로 애플리케이션 개발하기
### 14.4.1 애플리케이션 셋업
- 모듈 시스템의 여러 부분이 두르러질 수 있도록 잘게 분해하고 캡슐화한다면 장점에 비해 초기비용이 높아진다. 
- 프로젝트가 커지면서 많은 내부 구현이 추가되면 이때부터 캡슐화의 장점이 두드러진다.
- 각 모듈은 다른 모듈로 노출하고 싶지 않은 내부 구현을 포함한다. 
### 14.4.2 세부적인 모듈화와 거친 모듈화
- 시스템을 모듈화 할때 모듈의 크기를 결정해야 한다. 
- 세부적인 모듈화 기법 대부분은 모든 패키지가 자신의 모듈을 갖는다. 
- 거친 모듈화 기법은 한 모듈이 시스템의 모든 패키지를 포함한다. 
- 세부적인 모듈화는 설계 비용이 증가하는 반면 거친 모듈화는 모듈화의 모든 장점을 잃는다. 
- 가장 좋은 방법은 시스템을 실용적으로 분해하면서 진화하는 소프트웨어가 이해하기 쉽고 고치기 쉬운 수준으로 적절하게 모듈화되어 있는지 주기적으로 확인하는 프로세스를 갖는 것이다.
### 14.4.3 자바 모듈 시스템 기초
***
## 14.5 여러 모듈 활용하기
### 14.5.1 exports 구문
### 14.5.2 requires 구문
### 14.5.3 이름 정하기
***
## 14.6 컴파일과 패키징
***
## 14.7 자동모듈
***
## 14.8 모듈 정의와 구문들
### 14.8.1 requires
### 14.8.2 exports
### 14.8.3 requires transitive
### 14.8.4 exports to
### 14.8.5 open과 opens
### 14.8.6 users 와 provides
***
## 14.9 더 큰 예제 그리고 더 배울 수 있는 방법 


