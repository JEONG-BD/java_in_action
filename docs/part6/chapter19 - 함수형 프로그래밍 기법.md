# Chapter 18 함수형 관점으로 생각하기
## [목차] 
[19.1 함수는 모든 곳에 존재한다](#191-함수는-모든-곳에-존재한다)  
* [19.1.1 고차원 함수](#191-함수는-모든-곳에-존재한다)  
* [19.1.2 커링](#1912-커링)  
[19.2 영속 자료 구조](#192-영속-자료-구조)
* [19.2.1 파괴적인 갱신과 함수형](#1921-파괴적인-갱신과-함수형)
[19.3 스트림과 게으른 자기평가](#193-스트림과-게으른-자기-평가)
* [19.3.1 자기 정의 스트림](#1931-자기-정의-스트림)
* [19.3.2 게으른 리스트 만들기](#1932-게으른-리스트-만들기)
[19.4 패턴매칭](#194-패턴매칭)
* [19.4.1 방문자 디자인 패턴](#1941-방문자-디자인-패턴)
* [19.4.2 패턴 매칭의 힘](#1942-패턴-매칭의-힘)
[19.5 기타정보]()
* [19.5.1 캐싱 또는 지역화]()
* [19.5.2 같은 객체를 반환함은 무엇을 의미하는가?](#1952-같은-객체를-반환함은-무엇을-의미하는가)
* [19.5.3 콤비네이터](#1953-콤비네이터)


## 19.1 함수는 모든 곳에 존재한다.
- 함수형 언어 프로그래머는 함수형 프로그래밍이라는 용어를 폭넓게 사용한다. 
- 함수를 마치 일반 값처럼 사용해서 인수로 전달하거나, 결과를 반환 받거나 자료 구조에 저장할 수 있음을 의미한다. 
- 일반값 처럼 취급할 수 있는 함수를 일급함수 라고 한다. 
### 19.1.1 고차원 함수
- 함수형 프로그래밍 커뮤니티에 따르면 하나 이상의 함수를 인수로 받거나 함수를 결과로 반환하는 동작을 수행하는 함수를 고차원 함수라고 한다. 
- 자바 8에서는 함수 인수 전달 , 결과 반환 지역 변수 할당 등이 가능하므로 자바 8의 함수도 고차원 함수라고 할 수 있다. 
#### 부작용과 고차원 함수 
- 스트림 연산으로 전달하는 함수는 부작용이 없어야 하며 부작용을 포함하는 함수를 사용하면 문제가 발생한다. 
- 고차원 함수를 적용할 때도 이와 똑같은 규칙이 적용된다. 
## 19.1.2 커링
- 애플리케이션이 국제화를 지원해야 하는데 이때 단위 변환 문제가 발생할 수 있다. 
- 변환 요소와 기준치 조정 요소가 단위 변환 결과를 좌우한다. 
- 섭씨를 화씨로 변환하는 공식은 아래와 같다. 
```java
static double converter(double x, double f, double b){
    return x * f + b;
}
// x 는 변환할려는 값 
// f 는 변환 요소 
// b 는 기준치 조정 요소 
```
- 세개의 인수를 받는 위 메서드를 만들어서 문제를 해결 할 수도 있지만 인수에 요소, 기준치를 넣는 일은 귀찮다! 
- 커링이라는 개념을 활용해서 한 개의 인수를 갖는 변환 함수를 생산하는 팩토리를 정의하는 코드는 아래와 같다.

```java
import java.util.function.DoubleUnaryOperator;

static DoubleUnaryOperator curriedConverter(double f, double b){
    return (double x) -> x * f + b; 
}

DoubleUnaryOperator convertCtoF = curriedConverter(9.0/5, 32); 
DoubleUnaryOperator convertUSDtoGBP = curriedConverter(0.6, 0); 
DoubleUnaryOperator convertKmtoMi = curriedConverter(0.6214, 0);

double gbp = convertUSDtoGBP.applyAsDouble(1000);
```
#### 커링의 이론적 적의 
- 커링은 x와 y라는 두 인수를 받는 함수 f를 한 개의 인수를 받는 g라는 함수로 대체하는 기법이다. 
- g라는 함수 역시 하나의 인수를 받는 함수를 반환한다.
- 함수g와 원래 함수 f가 최종적으로 반환하는 값은 같다.f(x,y) = (g(x))(y)가 성립한다.
- 이와 같은 여러 과정이 끝까지 완료되지 않은 상태를 가리켜 함수가 부분적으로 partially 적용되었다라고 한다.

## 19.2 영속 자료 구조
- 함수형 프로그램에서 함수는 자료구조, 불변 자료구조 등의 용어도 사용하지만 영속 자료구조 라고 부른다. 
- 함수형 메서드에서는 전역 자료구조, 인수로 전달된 구조를 갱신할 수 없다. 구조를 바꾸면 같은 메서드를 두 번 호출 했을 때 결과가 달라지면서 참주 투명성에 위배된다. 
- 
### 19.2.1 파괴적인 갱신과 함수형
- 함수형에서는 부작용을 수반하는 메서드를 제한하는 방식으로 문제를 해결한다. 
- 계산 결과를 표현할 자료 구조가 필요하면 기존의 자료 구조를 갱신하지 않도록 새로운 자료구조를 만들어야 한다.
- 함수형 자료구조는 저장된 값이 다른 누군가에 의해 영향을 받지 않는 상태라고 한다. 자료구조를 바꾸지 말라는 것이 자료구조를 사용하는 모든 사용자에게 요구하는 단 한 가지 조건이다.

## 19.3 스트림과 게으른 자기 평가 
- 스트림은 단 한번만 소비할 수 있기 때문에 재귀적으로 정의할 수 없다. 
### 19.3.1 자기 정의 스트림
### 19.3.2 게으른 리스트 만들기
- 자바 8의 스트림은 게으르다. 스트림에 일련의 연산을 적용하면 연산이 수행되지 않고 일단 저장된다. 
- 최종 연산을 적용해서 실제 계산을 해야 하는 상황에서만 실제 연산이 이루어진다. 
- 게으른 특성 때문에 각 연산별로 스트림을 탐색할 필요없이 한번에 연산을 처리 가능하다. 
## 19.4 패턴매칭
### 19.4.1 방문자 디자인 패턴
- 자바에서는 방문자 디자인 패턴으로 자료협을 언랩 할 수 있다. 
- 특정 데이터 형식을 방문하는 알고리즘을 캡슐화하는 클래스를 만들 수 있다. 
### 19.4.2 패턴 매칭의 힘
## 19.5 기타정보
### 19.5.1 캐싱 또는 지역화
### 19.5.2 같은 객체를 반환함은 무엇을 의미하는가?
### 19.5.3 콤비네이터
- 함수형 프로그래밍에서는 두 함수를 인수로 받아 다른 함수를 반환하는 등 함수를 조합하는 고차원 함수를 많이 사용하게 된다. 
- 함수를 조합하는 기능을 콤비네이터라고 부른다. 
- 자바 8 API에 추가된 많은 기능은 콤비네이터 combinator의 영향을 받았다고 한다. 
- CompletableFuture 클래스에는 thenCombine이라는 메서드가 추가되었다. thenCombine 메 서드는 CompletableFuture와 BiFunction 두 인수를 받아 새로운 CompletableFuture를 생성 한다.