# Chapter 1 자바 8, 9, 10, 11 : 무슨 일이 일어나고 있는가? 
## 목차
[1.1. 역사의 흐름은 무엇인가? ](#11-역사의-흐름은-무엇인가)  
[1.2. 왜 아직도 자바는 변화하는가? ](#12-왜-아직도-자바는-변화하는가)  
* [1.2.1 프로그래밍 언어 생태계에서 자바의 위치](#121-프로그매밍-언어-생태계에서-자바의-위치)
* [1.2.2 스트림 처리](#122-스트림-처리) 
* [1.2.3 동작 파라미터화로 메서드를 코드에 전달하기](#123-동작-파라미터화로-메서드에-코드를-전달하기) 
* [1.2.4 병렬성과 공유 가변 데이터](#124-병렬성과-공유-가변-데이터) 
* [1.2.5 자바가 진화해야 하는 이유](#125-자바가-진화해야-하는-이유)

[1.3. 자바 함수 ](#13-자바-함수)    
* [1.3.1 메서드와 람다를 일급 시민으로](#131-메서드와-람다를-입급-시민으로)
* [1.3.2 코드 넘겨 주기](#132-코드-넘겨주기)

[1.4. 스트림](#14-스트림)  
* [1.4.1 멀티스레딩은 어렵다](#141-멀티-스레딩은-어렵다)  

[1.5. 디폴트 메서드와 자바 모듈](#15-디폴트-메서드와-자바-모듈)  
[1.6. 함수형 프로그래밍에서 가져온 다른 유용한 아이디어](#16-함수형-프로그램에서-가져온-유용한-아이디어)
*** 
## 1.1 역사의 흐름은 무엇인가? 

- 자바의 역사를 통틀어 가장 큰 변화가 자바 8에서 일어났다.  
- 자바 8을 이용하면 <U>**자연어**</U>에 더 가깝게 간단한 방식으로 코드를 구현할 수 있다. 
- 멀티코어 CPU의 대중화와 같은 하드웨어적인 변화가 자바 8에 영향을 미쳤다.    

    |버전|출시년도|특징|   
    |---|---|---|   
    |1|1996|스레드, 락|    
    |5|2004|스레드 풀, 병렬 실행 컬렉션|
    |7|2011|포크, 조인|
    |8|2014|스트림 API, 메서드를 코드로 전달, 인터페이스의 디폴트메서드| 
    |9|2017|리액티브 프로그래밍| 
    ```java
    // Before 
    // How
    Collections.sort(inventory, new Comparator<Apple>() {
        public int compare(Apple a1, Apple a2) {
            return a1.getWeigt().compareTo(a2.getWeight());
        }
    }); 
    // After
    // What  
    inventory.sort(comparing(Apple::getWeight));
    ```
- 자바 8은 함수형 프로그래밍에서 위력을 발휘한다. 

***

## 1.2 왜 아직도 자바는 변화하는가?
- 특정 분야에서 장점을 갖는 언어는 다른 경쟁 언어를 도태시킨다. 

### 1.2.1 프로그매밍 언어 생태계에서 자바의 위치  
- 코드를 JVM 바이트 코드로 컴파일 하는 특징 때문에 자바는 애플릿 프로그램의 주요 언어가 되었다.  
- 빅데이터라는 도전에 직면하면서 멀티코어 컴퓨터 컴퓨팅 클러스터를 이용해 빅데이터를 효과적으로 처리할 필요성이 커졌다.
- 병렬 프로세싱을 활용해야 하는데 이전 버전에서의 자바로는 충분히 대응할 수 없었다. 
- 자바 8은 더 다양한 도구와 프로그래밍 문제를 더 빠르고 정확히 유지보수 할 수 있다는 장점을 제공한다. 

### 1.2.2 스트림 처리 
- 스트림이란 한번에 한개씩 만들어지는 연속적인 데이터 항목들의 모임이다. 
- 자바 8에서 java.util.stream 패키지에 스트림 API가 추가 되었다.
    ```mermaid
    flowchart LR
        A[cat] --> B[tr]
        B --> C[sort]
        C --> D[tail -3]
    ```

- 스트림 API의 핵심은 기존에는 한번에 한 항목을 처리 했지만 자바 8에서는 고수준으로 추상화해서 일련의 스트림으로 만들어서 처리하는 것이 가능하다. 
- 스레드라는 복잡한 작업을 사용하지 않으면서도 <U>**공짜로 병렬성을 얻을 수 있다**</U>. 
- 스트림 API는 컬렉션에 대해서 수행할 수 있는 연산의 집합이다.  

### 1.2.3 동작 파라미터화로 메서드에 코드를 전달하기 
- 자바 8에서 추가된 두 번째 개념은 코드 일부를 API로 전달하는 기능이다.
- 자바 8에서는 메서드를 다른 메서드의 인수로 넘겨주는 기능을 제공하는데 이러한 기능을 <U>**동작 파라미터화(Behavior paremeterization)**</U>라고 한다.  
    ```mermaid
    flowchart LR
        A[cat] --> B[tr]
        B --> C[sort]
        C --> D[tail -3]
        
        subgraph Behavior Parameter
            X[CompareUsingCustomerId]
        end
        X --> C
    ```

- 스트림 API는 연산의 동작을 파라미터화 할 수 있는 코드를 전달한다는 사상에 기초 했다.

### 1.2.4 병렬성과 공유 가변 데이터 
- 스트림 메서드로 전달되는 코드는 다른 코드와 동시에 실행하더라도 안전하게 실행될 수 있어야 한다. 
- 공짜로 병렬성을 얻는 대신에 스트림 메서드로 전달하는 코드의 동작 방식을 조금씩 변경할 필요가 있다. 
- 다른 코드와 동시에 실행 하더라도 안전하게 실행할 수 있는 코드를 만들려면 가변 데이터에 접근하지 않아야 하며 이러한 함수를 순수 함수, 부작용 없는 함수, 상태 없는 함수라고 한다. 
- 공유된 변수 객체가 있을 경우 병렬성에 문제가 발생 하는데 기존의 synchronized가 아닌 자바 8의 스트림을 이용하면 병렬성을 활용이 가능하다. 


### 1.2.5 자바가 진화해야 하는 이유 
- 고전적인 객체지향에서 벗어나서 함수형 프로그래밍으로 다가섰다는 것이 자바 8의 가장 큰 변화이다. 
- 전통적인 객체지향 프로그래밍과 함수지향 프로그래밍은 완전 상극이지만 자바 8에서 함수형 프로그래밍을 도입함으로써 두가지 패러다임의 장점을 모두 활용하는 것이 가능하다. 

***
## 1.3 자바 함수 
- 프로그래밍 언어에서 함수라는 용어는 메서드 특히 정적 메서드와 같은 의미로 사용된다. 
- 자바의 함수는 이에 더해 수학적인 함수 처럼 사용되며 부작용을 일으키지 않는 함수를 의미한다. 
- 프로그래밍 언어의 핵심은 값을 바꾸는 것이다. 
- 프로그램을 실행하는 동안 이러한 구조체를 모두 자유롭게 전달 할 수 없었다.  
    #### 일급 시민과 이급 시민 
    - 일급 시민 
        - 변수에 할당 
        - 함수의 인자 또는 리턴 값으로 받기 
        - 배열이나 객체에 담기 

    - 이급 시민 
        - 수식 연산자 
        - 반복문 
        - 조건문 
        - try/catch 블록
        - 메서드 
        - 클래스 

### 1.3.1 메서드와 람다를 일급 시민으로 
- 메서드 참조 하는 새로운 자바 8의 기능은 다른 자바 기능 8의 토대를 제공했다. 
- 자바 8에서는 메서드가 이급 값이 아닌 일급 값이다. 
    ```java

    File[] hiddenFiles = new File(".").listFiles(new FileFilter() {
        public boolean accept(File file) {
            return file.isHidden();
        }
    })

    File[] hiddenFiles = new File(".").listFiles(File::isHidden);
    ```

    ####  람다 익명 함수 
    - 자바 8에서는 메서드를 일급 값으로 취급할 뿐 아니라 람다를 포함하여 함수도 값으로 취급할 수 있다.
    - 람다 문법 형식으로 구현된 프로그램을 함수형 프로그래밍 <U>**'함수를 일급값으로 넘겨주는 프로그램을 구현한다'**</U>라고 한다.  

### 1.3.2 코드 넘겨주기 
- 특정 항목을 선택해서 반환하는 동작을 필터 라고 하는데 자바 8에서는 filter 메서드를 중복으로 구현할 필요가 없다.  

### 1.3.3 메서드 전달에서 람다로 
- 메서드를 갑으로 전달하는 것은 유용하지만 한 두번 사용할 메서드를 매번 정의하는 것은 귀찮다. 자바 8에서는 이 문제도 간단하게 해결이 가능하다. 
- 람다가 몇 줄 이상 길어진다면 익명 람다 보다는 코드가 수행하는 일을 잘 설명하는 이름을 가진 메서드를 정의하고 메서드 참조를 활용해서 코드의 명확성을 우선시 하는 것이 바람직하다. 

***
## 1.4 스트림 
- 거의 모든 자바 애플리케이션은 컬렉션을 만들고 활용 하지만 컬렉션으로 모둔 문제가 해결되는 것은 아니다. 
- 스트림 API를 이용하면 컬렉션 API와는 상당히 다른 방식으로 데이터를 처리할 수 있다는 것이다.  
- for-each와 루프를 이용해서 각 요소를 직접 반복하면서 수행하는 것을 같은 외부 반복이라고 허는데 스트림 API의 내부 반복을 이용해서 처리가 가능하다.  

### 1.4.1 멀티 스레딩은 어렵다. 
- 이전 자바 버전에서는 제공하는 스레드 API로 멀티 스레딩 코드를 구현해서 병렬성을 이용하는 것은 쉽지 않다. 
- 기존의 컬렉션에서는 데이터를 처리할 때 반복되는 패턴이 많고 이를 주어진 조건에 따라서 필터링, 추출, 그룹화 하는 등의 동작들을 쉽게 병렬화해서 처리 가능하다. 
- <U>**컬렉션은 어떻게 데이터를 저장하고 접근할지에 중점을 두지만 스트림은 데이터에 어떤 계산을 할 것인지를 묘사하는 것에 중점을 둔다**</U>. 
- 외부에서 만들어진 컴포넌트를 이용해 시스템을 구축하는 경향이 있다. 
- 자바에서는 특별한 구조가 아닌 자바 패키지에 포함하는 JAR파일을 제공하는 것이 전부 였다. 
- 자바 9 모듈 시스템은 모듈을 정의하는 문법을 제공한다. 이를 이용해 패키지 모음을 포함하는 모듈을 정의할 수 있다. 

***
## 1.5 디폴트 메서드와 자바 모듈 
- 외부에서 만들어진 컴포넌트를 이용해 시스템을 구축하는 경향이 있고 이와 관련해서 지금까지는 자바에서는 특별한 구조가 아닌 자바 패키지 집합을 포함하는 JAR 파일을 제공하는 것이 전부 였지만 
자바 9 에서 모듈 시스템은 모듈을 정의하는 문법을 제공하므로 이를 이용해서 패지키 모음을 포함하는 모듈을 정의할 수 있다. 

- 패키지의 인터페이스를 변경할 경우 인터페이스를 구현하는 모든 클래스의 구현을 변경해야 하는 고통스러움이 있었다.  
- 자바 8은 구현 클래스에서 구현하지 않아도 되는 메서드를 인터페이스에 추가할 수 있는 기능을 제공하는데 메서드 본문이 구현 클래스가 아닌 인터페이스의 일부로 포함되므로 이를 디폴트 메서드라고 부른다. 
- 디폴트 메서드를 이용하면 기존의 코드를 건드리지 않고 원래의 언터페이스 설계를 자유롭게 확장이 가능하다.  
***

## 1.6 함수형 프로그램에서 가져온 유용한 아이디어 
- 자바 8에서는 NullPointer 예외를 피할 수 있도록 도와주는 Optional<T> 클래스를 제공한다. 
- Optional<T>는 값을 갖거나 갖지 않을 수 있는 컨테이너 객체다. Optional<T>는 값이 앖을 때 어떻게 처리할지 명시적으로 구현하는 메서드를 포함한다. 
- Optional<T>를 사용하면 NullPointer 예외를 피할 수 있다. 

***
> 마틴 게이브리얼 우르마, 『모던 자바 인 액션』, 한빛미디어 (2019)  
